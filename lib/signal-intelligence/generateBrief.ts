/**
 * Signal Intelligence Brief Generator
 * Creates executive-ready markdown briefs from derived insights
 * Works without LLM by default, can optionally polish with OpenAI
 */

import type { InsightCandidate, Brief, BriefSection } from './types';

interface BriefInput {
  insights: InsightCandidate[];
  runId: string;
  runDate: Date;
}

/**
 * Generate a markdown brief from derived insights
 */
export function generateBrief(input: BriefInput): Brief {
  const { insights, runDate } = input;
  
  // Categorize insights by severity and type
  const critical = insights.filter(i => i.severity === 'critical' || i.severity === 'high');
  const changes = insights.filter(i => i.category === 'ads');
  const surviving = insights.filter(i => i.title.toLowerCase().includes('surviving') || i.title.toLowerCase().includes('evergreen') || i.title.toLowerCase().includes('long-running'));
  const invisible = insights.filter(i => i.category === 'visibility');
  const strategic = insights.filter(i => i.category === 'strategy' || i.category === 'content');

  // Build sections
  const sections: BriefSection[] = [];

  // What Changed
  sections.push({
    title: 'What Changed',
    content: buildChangesSection(changes, runDate),
  });

  // What's Surviving
  sections.push({
    title: "What's Surviving",
    content: buildSurvivingSection(surviving),
  });

  // Where You're Invisible
  sections.push({
    title: "Where You're Invisible",
    content: buildInvisibleSection(invisible),
  });

  // Risks
  sections.push({
    title: 'Risks',
    content: buildRisksSection(critical, strategic),
  });

  // Next Moves (max 3 bullets)
  sections.push({
    title: 'Next Moves',
    content: buildNextMovesSection(insights),
  });

  // Generate headline
  const headline = generateHeadline(insights, runDate);

  return {
    headline,
    sections,
  };
}

/**
 * Convert Brief to markdown string
 */
export function briefToMarkdown(brief: Brief): string {
  const lines: string[] = [];
  
  lines.push(`# ${brief.headline}`);
  lines.push('');

  for (const section of brief.sections) {
    lines.push(`## ${section.title}`);
    lines.push('');
    for (const line of section.content) {
      lines.push(line);
    }
    lines.push('');
  }

  lines.push('---');
  lines.push('*Generated by Signal Intelligence*');

  return lines.join('\n');
}

// =============================================================================
// Section Builders
// =============================================================================

function buildChangesSection(changes: InsightCandidate[], runDate: Date): string[] {
  if (changes.length === 0) {
    return ['No significant ad changes detected in this scan period.'];
  }

  const lines: string[] = [];
  const dateStr = runDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric', year: 'numeric' });
  
  lines.push(`*Scan date: ${dateStr}*`);
  lines.push('');

  for (const insight of changes.slice(0, 3)) {
    lines.push(`- **${insight.title}**: ${insight.summary}`);
  }

  return lines;
}

function buildSurvivingSection(surviving: InsightCandidate[]): string[] {
  if (surviving.length === 0) {
    return ['No long-running patterns identified yet. More data needed for survival analysis.'];
  }

  const lines: string[] = [];

  for (const insight of surviving.slice(0, 3)) {
    lines.push(`- **${insight.title}**: ${insight.summary}`);
    
    // Add sample evidence if available
    const evidence = insight.evidence as Record<string, unknown>;
    if (evidence.samples && Array.isArray(evidence.samples)) {
      const samples = evidence.samples.slice(0, 2);
      for (const sample of samples) {
        if (typeof sample === 'object' && sample !== null) {
          const s = sample as Record<string, unknown>;
          if (s.title) {
            lines.push(`  - "${s.title}"`);
          } else if (s.archetype && s.days) {
            lines.push(`  - ${s.archetype} ad (${s.days} days)`);
          }
        }
      }
    }
  }

  return lines;
}

function buildInvisibleSection(invisible: InsightCandidate[]): string[] {
  if (invisible.length === 0) {
    return ['No visibility gaps detected. Local presence appears healthy.'];
  }

  const lines: string[] = [];
  const highPriority = invisible.filter(i => i.severity === 'high' || i.severity === 'critical');
  const moderate = invisible.filter(i => i.severity === 'medium');

  if (highPriority.length > 0) {
    lines.push('**Priority Issues:**');
    for (const insight of highPriority.slice(0, 2)) {
      lines.push(`- ${insight.summary}`);
    }
  }

  if (moderate.length > 0) {
    lines.push('');
    lines.push('**Improvement Areas:**');
    for (const insight of moderate.slice(0, 2)) {
      lines.push(`- ${insight.summary}`);
    }
  }

  if (highPriority.length === 0 && moderate.length === 0) {
    for (const insight of invisible.slice(0, 3)) {
      lines.push(`- ${insight.summary}`);
    }
  }

  return lines;
}

function buildRisksSection(critical: InsightCandidate[], strategic: InsightCandidate[]): string[] {
  const lines: string[] = [];

  if (critical.length === 0 && strategic.length === 0) {
    return ['No significant risks identified in this scan.'];
  }

  // Critical risks first
  for (const insight of critical.slice(0, 2)) {
    lines.push(`- **${insight.title}**: ${insight.summary}`);
  }

  // Strategic risks
  const platformRisk = strategic.find(i => i.title.toLowerCase().includes('platform') || i.title.toLowerCase().includes('dependency'));
  if (platformRisk) {
    lines.push(`- **${platformRisk.title}**: ${platformRisk.summary}`);
  }

  return lines;
}

function buildNextMovesSection(insights: InsightCandidate[]): string[] {
  const moves: string[] = [];
  
  // Prioritize by severity
  const highSeverity = insights.filter(i => i.severity === 'high' || i.severity === 'critical');
  const mediumSeverity = insights.filter(i => i.severity === 'medium');
  
  // Generate actionable recommendations
  if (highSeverity.some(i => i.category === 'visibility')) {
    moves.push('1. **Address visibility gaps** - Update profiles on flagged platforms this week');
  }

  const longRunning = insights.find(i => i.title.toLowerCase().includes('long-running'));
  if (longRunning) {
    moves.push(`${moves.length + 1}. **Study surviving ads** - Review competitor messaging that's proven to last`);
  }

  const platformDep = insights.find(i => i.title.toLowerCase().includes('platform') && i.severity !== 'info');
  if (platformDep) {
    moves.push(`${moves.length + 1}. **Diversify channels** - Reduce dependency on single platform`);
  }

  const contentInsight = insights.find(i => i.category === 'content' && i.title.toLowerCase().includes('topic'));
  if (contentInsight && moves.length < 3) {
    moves.push(`${moves.length + 1}. **Content alignment** - Evaluate if your content covers key competitor topics`);
  }

  // Fallback recommendations
  if (moves.length === 0) {
    moves.push('1. **Continue monitoring** - Set up regular scan cadence');
    moves.push('2. **Expand data sources** - Add more competitors to tracking');
  }

  // Limit to 3 max
  return moves.slice(0, 3);
}

function generateHeadline(insights: InsightCandidate[], runDate: Date): string {
  const dateStr = runDate.toLocaleDateString('en-US', { month: 'short', day: 'numeric' });
  
  const critical = insights.filter(i => i.severity === 'critical' || i.severity === 'high');
  const adInsights = insights.filter(i => i.category === 'ads');
  
  if (critical.length >= 3) {
    return `Signal Brief: ${critical.length} Priority Issues - ${dateStr}`;
  }
  
  if (adInsights.length > 0) {
    const longRunning = insights.find(i => i.title.toLowerCase().includes('long-running'));
    if (longRunning) {
      return `Signal Brief: Ad Survival Patterns Detected - ${dateStr}`;
    }
    return `Signal Brief: ${adInsights.length} Ad Insights - ${dateStr}`;
  }

  return `Signal Brief: Market Intelligence Update - ${dateStr}`;
}

// =============================================================================
// Optional OpenAI Polish (only if API key exists)
// =============================================================================

/**
 * Optionally polish the brief with OpenAI if API key is available
 * Falls back to template version if not configured
 */
export async function polishBriefWithAI(markdown: string): Promise<string> {
  const apiKey = process.env.OPENAI_API_KEY;
  
  if (!apiKey) {
    // Return unpolished version
    return markdown;
  }

  try {
    const response = await fetch('https://api.openai.com/v1/chat/completions', {
      method: 'POST',
      headers: {
        'Content-Type': 'application/json',
        'Authorization': `Bearer ${apiKey}`,
      },
      body: JSON.stringify({
        model: 'gpt-4o-mini',
        messages: [
          {
            role: 'system',
            content: 'You are an executive brief editor. Polish the following market intelligence brief for clarity and impact. Keep the same structure and information, but improve readability and punch. Be concise. Do not add information that is not present.',
          },
          {
            role: 'user',
            content: markdown,
          },
        ],
        max_tokens: 2000,
        temperature: 0.3,
      }),
    });

    if (!response.ok) {
      console.error('[BriefGenerator] OpenAI API error:', response.status);
      return markdown;
    }

    const data = await response.json();
    const polished = data.choices?.[0]?.message?.content;
    
    return polished || markdown;
  } catch (error) {
    console.error('[BriefGenerator] Failed to polish with AI:', error);
    return markdown;
  }
}
